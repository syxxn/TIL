## 4.1-4.2 @Entity, @Table

엔티티와 테이블을 매핑하는 방법으로는 XML과 어노테이션이 있다. 각각의 장단점이 있지만 어노테이션을 사용하는 쪽이 더 쉽고 직관적이다.

<br>

## @Entity

JPA를 사용해서 **테이블과 매핑할 클래스**는 @Entity 어노테이션을 필수로 붙여야 한다.

### 속성

#### name

JPA에서 사용할 엔티티 이름을 정한다. 보통 기본값인 클래스 이름을 사용한다.

### 특징

+ 기본 생성자는 필수(public, protected)

  > JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하기 때문에 필요하다.

+ final 클래스, enum, interface, inner 클래스에는 사용 불가

+ 저장할 필드에 final 사용 불가

<br>

## @Table

**엔티티와 매핑할 테이블**을 지정한다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.

### 속성

#### name

매핑할 테이블 이름을 설정한다. 생략하면 엔티티 이름을 사용한다.

#### uniqueConstraints

DDL 생성 시에 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다.

이 기능은 스키마 자동 생성 기능을 사용해서 DDL을 만들 때만 사용된다.

> JPA는 이와 같이 애플리케이션의 실행 동작에는 영향을 주지 않지만, 자동 생성되는 DDL을 위한 기능들도 있다.
> 스키마 자동 생성 기능을 사용하지 않고 직접 DDL을 만든다면 사용할 이유가 없다.
>
> 이런 기능을 사용하면 개발자가 엔티티만 보고도 손 쉽게 조건을 파악할 수 있는 장점이 있다.

#### catalog

catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다.

> 데이터베이스의 개체들의 대한 정의를 담고 있는 메타데이터들로 구성된 데이터베이스 내의 인스턴스이다.
> 쉽게 말하자면, 시스템 내의 모든 객체에 대한 정의나 명세를 말하며, **데이터 사전**이라고도 한다.

#### schema

schema 기능이 있는 데이터베이스에서 schema를 매핑한다.

> MySQL에서는 table과 schema가 동일한 의미로 사용된다고 하지만, 보통 schema는 table들의 집합이고, database는 schema 들의 집합이라고 한다.

*catalog과 schema의 예시를 들고 싶었는데.. 검색했을 때 잘 나오지를 않아서 사용하게 되면 추가하는 걸로~*
## 3.1 엔티티 매니저 팩토리와 엔티티 매니저

JPA가 제공하는 기능은 크게 1. 엔티티와 테이블을 매핑하는 설계 부분과 2. 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있다.

엔티티 매니저를 활용하여 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등의 일을 어떻게 처리하는 지 알아보자.

<br>

### 엔티티 매니저

엔티티 매니저란, 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 될 듯 싶다.

엔티티 매니저는 엔티티를 DB에 저장하기 위함이 아니라 영속성 컨텍스트에 저장하기 위해 사용하는 것이다.

<br>

### 엔티티 매니저 팩토리

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpaBook"); //persistence.xml에 있는 코드를 참고하기 위함.
```

엔티티 매니저를 만들기 위한 공장이다. 공장을 만드는 비용은 크기 때문에 하나를 만들어서 애플리케이션 전체에서 공유하는 것을 권장한다.

여러 스레드가 동시에 접근해도 안전하다.

엔티티 매니저를 생성하는 비용은 거의 없으며, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생할 수 있으므로 조심해야 한다.

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. 보통 트랜잭션을 시작할 때 커넥션을 획득한다.

<br>

## 3.2 영속성 컨텍스트란?

영속성 컨텍스트(Persistence Context)란, **엔티티를 영구 저장하는 환경**이라는 뜻이다.

**엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리**한다.

```java
em.persist(member);
```

영속성 컨텍스트는 논리적인 개념에 가깝다고 한다.

영속성 컨텍스트는 엔티티 매니저를 생성할 때 '하나' 만들어진다. (일단 하나의 엔티티 매니저에서 하나의 영속성 컨텍스트가 생성된다고 생각하자)

그리고 엔티티 매니저를 통해서 영속성 컨텍스트에 접근하고 관리하는 것이다.

<br>

## 3.3 엔티티의 생명주기

### 비영속 Transient

엔티티 객체를 생성한 후, 아직 엔티티 매니저와 아무런 작업을 같이 하지 않은 것이다.

영속성 컨텍스트나 DB와는 전혀 관련이 없다.

```java
User user = new User("name", "age");
```

### 영속 Managed

엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장하여 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.

`em.persist()` 이외에 `em.find()`나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태이다.

### 준영속 Detached

영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.

+ 특정 엔티티를 준영속 상태로 만드는 경우 `em.detach()`
+ 영속성 컨텍스트를 닫는 경우 `em.clear()`
+ 영속성 컨텍스트 초기화 `em.clear()`

> 엔티티 매니저를 직접 사용하기 보다 Sprnig Data JPA를 통해 사용해왔기 때문에 Spring Data JPA에서의 준영속 상태가 궁금했다.
>
> 친구의 경험에 따르면,
>
> + 하나의 트랜잭션으로 묶어둔 메소드를 벗어나는 경우
> + Osiv true인데 Controller에서 반환하는 Dto에서 엔티티를 갖고 있는 경우
> + 엔티티를 다른 자료형으로 변환시키고, 다시 엔티티로 변환 시키는 경우
>
> 요런 경우에서 준영속이 발생했다고 한다. 근데 의도해서 사용하는 경우도 있나.. 잘 모르겠다.

### 삭제 Removed

엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

`em.remove()`
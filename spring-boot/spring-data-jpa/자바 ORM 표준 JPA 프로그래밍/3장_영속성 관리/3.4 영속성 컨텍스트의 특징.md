## 3.4 영속성 컨텍스트의 특징

+ 영속 상태는 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)이 반드시 있어야 한다.
+ JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영(flush)한다.

### 장점

다음과 같은 장점이 있다.

#### 1차 캐시

영속성 컨텍스트 내에 존재하는 저장소로 on-off할 수 있는 옵션이 아니다. 트랜잭션/요청 내에서만 유지된다.

1차 캐시에서 찾지 못한 경우에 데이터베이스에서 조회한다.

#### 동일성 보장 Identify

EntityManager에서 하나의 객체를 여러 번 호출해도 항상 같다(==)는 것을 보장한다.

+ 동일성 : 실제 인스턴스가 같다(==)
+ 동등성 : 실제 인스턴스는 다를 수 있지만, 인스턴스가 가지고 있는 값이 같다(equals())

#### 트랜잭션을 지원하는 쓰기 지연 Transactional Write-Behind

SQL 저장소에 변경 사항이 있는 SQL문을 저장해 두었다가 트랜잭션이 커밋될 때 실행한다.

등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용이 없다.

쓰기 지연 기능을 통해 쿼리를 모아서 데이터베이스에 한 번에 전달하면 성능을 최적화할 수 있다.

#### 변경 감지 Dirty Checking

영속성 컨텍스트에 저장된 엔티티와 비교하여 변경사항이 있는 경우 변경사항을 데이터베이스에 적용시킨다.

JPA로 엔티티를 수정할 때 트랜잭션 커밋 직전에 `em.update()`와 같은 메소드를 실행하지 않는다. 데이터만 변경하면 데이터베이스에 자동으로 반영시킨다. 단, **영속 상태의 엔티티**여야 한다.

JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해 두는데, 이것을 **스냅샷**이라고 한다. flush 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티가 있으면 쓰기 지연 SQL 저장소에 보내는 것이다.

JPA의 기본 전략으로 인해 하나의 필드만 수정되었어도 엔티티의 모든 필드를 업데이트한다.

+ 데이터베이스에 보내는 데이터 전송량이 증가한다.
+ 모든 필드를 사용하면 수정 쿼리가 항상 같아서(데이터는 다르다) 미리 생성해두고 재사용할 수있다.

필드가 많거나(30개 이상 정도) 저장되는 내용이 큰 경우에는 엔티티 클래스에 `@org.hibernate.annotations.DynamicUpdate` 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성한다.

#### 지연 로딩 Lazy Loading

연관 관계가 매핑되어 있는 엔티티를 조회할 때 프록시 객체를 반환하고, 실제 사용할 때 쿼리를 실행시킨다.


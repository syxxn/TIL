## 3.6 준영속

전에도 설명했듯이 준영속은 **영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것**을 말한다.

따라서 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

> 영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다.
>
> 개발자가 직접 준영속 상태로 만드는 일은 드물다.

<br>

#### em.detach(entity)

특정 엔티티만 준영속 상태로 전환하는 메소드이다.

이 메소드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.

#### em.clear()

영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.

#### em.close()

영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.

<br>

### 특징

#### 거의 비영속 상태에 가깝다

비영속 상태와 준영속 상태의 차이는 비영속 상태는 DB에 저장하기 전인 순수한 객체이지만, 준영속 상태는 영속 상태였다가 풀린 것인 것 같다.

피지도 않았던 꽃과 피었다 진 꽃은 다른 느낌~

#### 식별자 값을 갖고 있다.

비영속 상태는 식별자 값이 없을 수도 있지만, 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.

영속성 컨텍스트에서 분리되었을 뿐 DB에서 분리된 것은 아니다.

#### 지연 로딩을 할 수 없다.

실제 객체 대신 프록시 객체를 로딩해두고 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 지연로딩은 사용할 수 없다.

<br>

### merge(entity)

준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합 merge()을 사용하면 된다.

merge()는 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.

> (+) `em.contains(entity)`는 영속성 컨텍스트가 entity를 관리하는지 확인하는 메소드이다.

merge()은 비영속 엔티티도 영속 상태로 만들 수 있다.

파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트를 조회하고 찾는 엔티티가 없으면 데이터베이스에서 조회한다. 만약 데이터베이스에서도 발견하지 못하면 새로운 엔티티를 생성해서 병합한다. 즉, 병합은 **save or update** 기능을 수행한다.